# 03-Rerank（二階段檢索）與常見模型

## 你將學到（Learning Objectives）

- 知道 rerank 在 RAG 裡為什麼常常是「提準的關鍵槓桿」
- 能理解二階段檢索：**召回（recall）** 與 **排序（precision）** 的分工
- 能把 rerank 放進工程架構而不綁定供應商（抽象介面）

## 本章地圖

- **適合用在**：候選召回很雜、命中率不穩、需要把「相關性」做上去時。
- **你會做出**：二階段檢索流程、rerank 候選數與延遲控制策略。
- **最可能踩雷**：候選集合品質太差；rerank 超時導致整體 SLA 崩潰。

## 為什麼需要 rerank

向量相似度擅長「語意近」，但不一定擅長「最相關且能回答」：

- query 很短、含術語/編號時，向量分數容易不穩
- 候選 chunks 很像（同一份文件不同段落）時，top-k 可能缺乏多樣性
- 真正的答案可能需要「精準匹配前提」或「包含例外條件」的段落

rerank 的價值：用更強的判別方式，重新排序候選，讓最終給 LLM 的證據更準。

## 二階段檢索（標準套路）

1. **第一階段召回（便宜、快）**
   - 向量 top-k、全文 top-k、多路召回
   - 目標：高 recall（先別漏）

2. **第二階段 rerank（較貴、較慢但更準）**
   - 對候選（例如 20～100 個）逐一評分排序
   - 目標：高 precision（把最相關的放前面）

## rerank 的常見做法（概念）

### 1) Cross-encoder / Re-ranker model

- 輸入：（query, chunk_text）
- 輸出：相關性分數
- 優點：通常很準
- 缺點：計算成本較高（候選數越多越慢）

### 2) LLM-as-a-reranker（要小心）

- 用 LLM 判斷哪幾段最能回答
- 優點：可以加上任務特定規則（例如必須包含條款編號）
- 缺點：成本高、穩定性與可控性較差；需要嚴格限制輸出格式

### 3) 規則/啟發式（搭配使用）

- 例如：包含條款編號/型號/關鍵字的 chunks 加分
- 優點：便宜、可控
- 缺點：泛化性有限；通常作為輔助而非主力

## 工程導入建議（不綁供應商）

把 rerank 當作一個可替換介面：

- input：query + candidates（chunk_id、text、metadata、初始分數）
- output：排序後 candidates（含 rerank 分數與原因可選）

你可以先上線：
- rerank = 關閉（只用向量排序）
然後逐步加入：
- rerank = cross-encoder（最常見）
- rerank = LLM rerank（只在特定場景）

## 常見坑

- **rerank 候選數太大**：成本暴增、延遲爆炸（先控制候選數）
- **沒有觀測**：你不知道 rerank 到底有沒有幫助（要記錄前後排名差異）
- **越權風險**：候選集合如果沒先做 ACL filter，rerank/LLM 可能看見不該看的內容

## 本章小結

- rerank 是把「不漏」變成「變準」的常見關鍵，尤其在 hybrid/多路召回後。
- rerank 的主要風險是延遲與成本：候選數、batch、timeout 與降級必須先設好。
- rerank 也要可回放：候選集合、分數、最終選取與版本都要進 trace。

## 延伸閱讀

- [02-top-k-filter-MMR-多路召回](02-top-k-filter-MMR-多路召回.md)
- [01-離線評估：Retrieval-Answer指標與資料集](../06-評估與觀測（讓工程團隊能迭代）/01-離線評估：Retrieval-Answer指標與資料集.md)
